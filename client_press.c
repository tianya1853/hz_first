#include "hz_include.h"

//unsigned gmac=0;

typedef struct _HeartbeatInfo_s
{
	uint8_t 	seconds;
	uint8_t 	minites;
	uint8_t 	hours;
	uint8_t 	days;
	uint8_t 	numberOfConnectedUEs;
	uint8_t 	isDspHearbeatRecv;
	uint8_t		rfEnable;/*0表示射频关闭，1表示射频打开*/
	uint8_t		RateMsg4PkMsg3;
	uint8_t 	RateMsg5PkMsg4;
	uint8_t 	padding[3];
}HeartbeatInfo_s;
typedef struct msg_struct
{
	u16	head;				//头部标识 0xffff
	u16	pkt_type;			//消息类型
	u8	serialNum[6];			//基站编号
	u16	identity;			//基站ID
	u16	session_id;			//上下文ID
	u16	data_length;			//消息长度
	//u8	data[data_length];		//DATA
	HeartbeatInfo_s stru_data;
}msg_heartbeat_s;



typedef struct msg_struct_head
{
	u16	head;				//头部标识 0xffff
	u16	pkt_type;			//消息类型
	u8	serialNum[6];			//基站编号
	u16	identity;			//基站ID
	u16	session_id;			//上下文ID
	u16	data_length;			//消息长度
	//u8	data[data_length];		//DATA
}msg_head_s;


hz_ret_t hz_memdumpsocket(FILE *fp,d8 *buf,s32 length)
{
	s32 i=0;
	hz_ret_t ret = RET_SUCCESS ;
	fprintf(fp,"dump buf=%p length=%d\n",buf,length) ;

	if ( buf != NULL && length > 0  )
	{
		for(;i< length;i++)
		{
			fprintf(fp,"%02x ",(u8)*(buf+i) );
			if ( i % 10 == 9 ) fprintf(fp,"\n");
		}
		fprintf(fp,"\n");		
	}else
	{
		ret = RET_ERR_MEMDUMP;
	}



	fprintf(fp,"dump done\n") ;
	return 0 - ret;
}




d8 ueinfo_16[]={
0xff,0xff,0x00,0x02,0xc4,0xed,0xba,0xa3,0x40,0xd8,0x00,0x00,0x01,0x0d,0x03,0x88,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,

0x00,0x00,0x00,0x00,0x04,0x60,0x02,0x86,0x37,0x80,0x64,0x95,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xd9,0x08,0x46,0x9b,0x58,0x11,0x00,
0x00,0x00,0x00,0x00,0x16,0x32,0x0b,0x17,0x02,0x00,0x00,0x07,0xe1,0x0f,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,

0x00,0x00,0x00,0x00,0x04,0x60,0x00,0x41,0x43,0x68,0x91,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0,0x07,0x56,0x2d,0x58,0x10,0x00,0x00,0x00,0x00,0x00,0x17,0x32,0x0b,0x17,0x02,0x00,0x00,0x07,0xe1,0x0f,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x04,0x60,0x00,0x90,0x30,0x89,0x05,0x92,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfb,0x07,0x4a,0xa5,0x58,0x11,0x00,0x00,0x00,0x00,0x00,0x19,0x32,0x0b,0x17,0x02,0x00,0x00,0x07,0xe1,0x0f,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x04,0x60,0x02,0x55,0x31,0x70,0x19,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xd6,0x0b,0xb8,0xfa,0x58,0x11,0x00,0x00,0x00,0x00,0x00,0x19,0x32,0x0b,0x17,0x02,0x00,0x00,0x07,0xe1,0x0f,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x04,0x60,0x02,0x76,0x30,0x58,0x29,0x51,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xcb,0x11,0x17,0x71,0x58,0x12,0x00,0x00,0x00,0x00,0x00,0x1a,0x32,0x0b,0x17,0x02,0x00,0x00,0x07,0xe1,0x0f,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x04,0x60,0x00,0x54,0x35,0x02,0x94,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xdc,0x0b,0x61,0x63,0x58,0x11,0x00,0x00,0x00,0x00,0x00,0x1c,0x32,0x0b,0x17,0x02,0x00,0x00,0x07,0xe1,0x0f,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x04,0x60,0x00,0x53,0x11,0x85,0x49,0x63,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0,0x8b,0x8b,0x81,0x58,0x11,0x00,0x00,0x00,0x00,0x00,0x1f,0x32,0x0b,0x17,0x02,0x00,0x00,0x07,0xe1,0x0f,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x04,0x60,0x02,0x86,0x40,0x33,0x16,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xcb,0x83,0xdd,0xb1,0x58,0x11,0x00,0x00,0x00,0x00,0x00,0x23,0x32,0x0b,0x17,0x02,0x00,0x00,0x07,0xe1,0x0f,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x04,0x60,0x02,0x26,0x91,0x47,0x90,0x63,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0x01,0x48,0x00,0x58,0x11,0x00,0x00,0x00,0x00,0x00,0x25,0x32,0x0b,0x17,0x02,0x00,0x00,0x07,0xe1,0x0f,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x04,0x60,0x00,0x41,0x94,0x61,0x87,0x15,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xce,0x0e,0xd0,0x11,0x58,0x11,0x00,0x00,0x00,0x00,0x00,0x05,0x33,0x0b,0x17,0x02,0x00,0x00,0x07,0xe1,0x0f,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x04,0x60,0x02,0x96,0x66,0x01,0x14,0x72,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc5,0x0d,0x75,0x8f,0x58,0x11,0x00,0x00,0x00,0x00,0x00,0x10,0x33,0x0b,0x17,0x02,0x00,0x00,0x07,0xe1,0x0f,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x04,0x60,0x02,0x21,0x54,0x30,0x35,0x77,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf4,0x0e,0x82,0x77,0x58,0x11,0x00,0x00,0x00,0x00,0x00,0x11,0x33,0x0b,0x17,0x02,0x00,0x00,0x07,0xe1,0x0f,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x04,0x60,0x02,0x65,0x34,0x99,0x67,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xcb,0x16,0x23,0x8e,0x58,0x12,0x00,0x00,0x00,0x00,0x00,0x1b,0x33,0x0b,0x17,0x02,0x00,0x00,0x07,0xe1,0x0f,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x04,0x60,0x02,0x86,0x45,0x13,0x19,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc6,0x00,0xf4,0x9d,0x58,0x11,0x00,0x00,0x00,0x00,0x00,0x26,0x33,0x0b,0x17,0x02,0x00,0x00,0x07,0xe1,0x0f,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x04,0x60,0x02,0x15,0x20,0x05,0x07,0x62,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xdd,0x86,0xce,0x46,0x58,0x11,0x00,0x00,0x00,0x00,0x00,0x30,0x33,0x0b,0x17,0x02,0x00,0x00,0x07,0xe1,0x1a,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x04,0x60,0x02,0x86,0x37,0x81,0x97,0x77,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xd1,0x05,0xdb,0x66,0x58,0x11,0x00,0x00,0x00,0x00,0x00,0x1c,0x34,0x0b,0x17,0x02,0x00,0x00,0x07,0xe1,0x0f,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};



typedef struct _UeInfo							//UE信息数据结构
{
	uint32_t					padding1;
	uint8_t						ueImsi[8];
	uint8_t						ueImei[8];
	uint8_t						ueSTmsi[5];
	uint8_t						ueTaType;	//26		//位置更新类型
	uint8_t						BoolInlib;
	uint8_t						Boolsys;
	uint16_t					RARta;//30
	uint8_t						padding2;
	uint8_t						tm_sec;	
	uint8_t						tm_min;	
	uint8_t						tm_hour;
	uint8_t						tm_mday;
	uint8_t						tm_mon;
	int						tm_year;//40	
	uint8_t						Code_province;
	uint8_t						Code_city;			//位置更新类型
	uint8_t						Code_operator;
	uint8_t						BoolLocaleInlib;
	uint32_t					padding3[3];//56
}UeInfo_s;

typedef struct _SendUeInfo					//UE信息数据结构
{
	uint32_t					padding;
	uint32_t					Count_UEinfo;
	UeInfo_s					UEinfo[16];
}SendUeInfo;


typedef struct msg_struct_ue
{
	u16	head;				//头部标识 0xffff
	u16	pkt_type;			//消息类型
	u8	serialNum[6];			//基站编号
	u16	identity;			//基站ID
	u16	session_id;			//上下文ID
	u16	data_length;			//消息长度
	//u8	data[data_length];		//DATA
	u32	padding;
	u32	Count_UEinfo;
	UeInfo_s stru_data[16];
}msg_UeInfo_s;




void *client_send_handle(void*arg)
{
	int res=0;
	int timecount=0;
	int ue_cnt;
	socket_creat_arg_t *sock_arg=(socket_creat_arg_t *)arg;
	lt_sleep(1);
#if 0
	d8 filename[100];
	sprintf(filename,"log/0x%04x.log",sock_arg->userdata[0] );
	if ( sock_arg->logfile_fp ==NULL )
	{	
		sock_arg->logfile_fp = fopen(filename,"a");		
	}	
	
	if ( sock_arg->logfile_fp != NULL )
	{
		lt_info("open file %p",sock_arg->logfile_fp);
		lt_info("user 0x%04x log file=%s",sock_arg->userdata[0],filename);
	}else
	{
		lt_info("can not open file %s ",filename);
		return NULL;		
	}
#endif 
	msg_heartbeat_s msg_heartbeat={0xffff,0x0100,{0xc4,0xed,0xba,0xa3,0x40,0xd8,},0x0,0x4903,sizeof(HeartbeatInfo_s),{0x1e,0x2b,0,0,0,0x01,0x01,0xfe,0xfe,{0,0,0}}};	
	
	static u32 imsi_value=0;
	//int mymac=gmac++;
	while(1)
	{
		timecount ++ ;
		fflush(sock_arg->logfile_fp);
		//memset(&msg_heartbeat,0,sizeof(msg_heartbeat) );
		//lt_sleep(3);
		lt_sleep(1);
		
		//msg_heartbeat.serialNum[5]=(mymac>>0)&0xff;
		//msg_heartbeat.serialNum[4]=(mymac>>8)&0xff;
		

		if (timecount %3==2)
		{//heartbeat
			msg_heartbeat.data_length= ( (sizeof(HeartbeatInfo_s)&0xff)<<8 ) + (sizeof(HeartbeatInfo_s)>>8) ;
			msg_heartbeat.identity= ( (sock_arg->userdata[0]&0xff)<<8 ) + (sock_arg->userdata[0]>>8) ;  
			lt_info("userdata[0]=0x%x",sock_arg->userdata[0]);
			lt_info("msg_heartbeat.identity=0x%x",msg_heartbeat.identity);
			msg_head_s *head=(msg_head_s *)ueinfo_16;
			head->identity=( (sock_arg->userdata[0]&0xff)<<8 ) + (sock_arg->userdata[0]>>8);

			res=socket_write(sock_arg,(d8 *)&msg_heartbeat,sizeof(msg_heartbeat),0);
		
			if ( res != SUCCESS )
			{
				//网络异常
				lt_error("socket send FAIL \n");
				//fprintf(sock_arg->logfile_fp,"socket send FAIL \n");
				break;
			}
			lt_info("********************heartbeat identity= 0x%04x  send",msg_heartbeat.identity);	
			lt_info("********************heartbeat confd   = 0x%04x  ",sock_arg->connectfd);

		}

		if (  timecount % sock_arg->userdata[2] == 0  )  //secs
		{//ueinfo
			lt_info("********************secs = 0x%04x sesc/one time ",sock_arg->userdata[2]);
			lt_info("********************uecnt= 0x%04x uecnt/one time ",sock_arg->userdata[1]);
			msg_UeInfo_s * uemsg_p=(msg_UeInfo_s *)ueinfo_16;


			
			u16 tmplen=sizeof(UeInfo_s)*sock_arg->userdata[1] + 8 ;
			uemsg_p->data_length= ( ( tmplen &0xff)<<8 ) + (  tmplen >>8 ) ;
			uemsg_p->Count_UEinfo=sock_arg->userdata[1]<<24;


			for (ue_cnt=0; ue_cnt<sock_arg->userdata[1] ; ue_cnt++ )
			{
				imsi_value ++ ;
				uemsg_p->stru_data[ue_cnt].tm_sec =( imsi_value%60 )&0xff;
				uemsg_p->stru_data[ue_cnt].tm_min =( imsi_value/60%60)&0xff;
				uemsg_p->stru_data[ue_cnt].tm_hour=( imsi_value/3600%24)&0xff;
				uemsg_p->stru_data[ue_cnt].tm_mday=( (imsi_value/3600/24+1)%31)&0xff;
				uemsg_p->stru_data[ue_cnt].tm_mon =( (imsi_value/3600/24/30+1)%13)&0xff;
				uemsg_p->stru_data[ue_cnt].tm_year=0xe3070000;
			}
			res=socket_write(sock_arg,ueinfo_16,sizeof(msg_head_s) + tmplen,0);		
			if ( res != SUCCESS )
			{
				//网络异常
				lt_error("socket send FAIL \n");
				//fprintf(sock_arg->logfile_fp,"socket send FAIL \n");
				break;
			}
			lt_info("********************imsi           = 0x%04x  send",imsi_value);	
			lt_info("********************ueinfo identity= 0x%04x  send",msg_heartbeat.identity);	
			lt_info("********************ueinfo confd   = 0x%04x  ",sock_arg->connectfd);


		}


		
		///fprintf(sock_arg->logfile_fp,"********************identity= 0x%04x  send\n",msg_heartbeat.identity);	
		//fprintf(sock_arg->logfile_fp,"********************confd   = 0x%04x  \n",sock_arg->connectfd);
	}
	//fflush(sock_arg->logfile_fp);
	//fclose(sock_arg->logfile_fp);  //exist bug ,will report segment error
	//sock_arg->logfile_fp =NULL;
	return NULL;
}


void *client_recv_handle(void*arg)
{
	s32 res=0;
	d8 string[1024];
	socket_creat_arg_t *sock_arg=(socket_creat_arg_t *)arg;

	lt_sleep(1);
	
#if 0
	d8 filename[100];
	sprintf(filename,"log/0x%04x.log",sock_arg->userdata[0] );
	if ( sock_arg->logfile_fp ==NULL )
	{	
		sock_arg->logfile_fp = fopen(filename,"a");		
	}	
	
	if ( sock_arg->logfile_fp != NULL )
	{
		lt_info("open file %p",sock_arg->logfile_fp);
		lt_info("user 0x%04x log file=%s",sock_arg->userdata[0],filename);
	}else
	{
		lt_info("can not open file %s ",filename);
		return NULL;		
	}
#endif



	
	//dont add   pthread_detach( pthread_self() )
	while(1)
	{		
		///lt_sleep(1);	
		//fflush(sock_arg->logfile_fp);
		memset(string,0,sizeof(string))	;
		res=socket_read(sock_arg,string,sizeof(string)-1,0);		
		if ( res <= 0 )
		{
			//网络异常
			//lt_error("socket recv FAIL \n");
			lt_error("socket recv FAIL \n");
			break;
		}else
		{
			lt_info("********************user = 0x%04x  recv msg",sock_arg->userdata[0]);
			lt_info("********************confd= 0x%04x  ",sock_arg->connectfd);
			hz_memdump(string,res);

			//fprintf(sock_arg->logfile_fp,"********************user = 0x%04x  recv msg\n",sock_arg->userdata[0]);
			//fprintf(sock_arg->logfile_fp,"********************confd= 0x%04x  \n",sock_arg->connectfd);			
			//hz_memdumpsocket(sock_arg->logfile_fp,string,res);
		}	
		//break;	
	}
	//fflush(sock_arg->logfile_fp);
	//fclose(sock_arg->logfile_fp); //exist bug ,will report segment error
	//sock_arg->logfile_fp =NULL;
	return NULL;
}



int main (int argc,char **argv)
{
	u32 i=0;
	d8 log_file[100];


	
	//lt_info("port =%s",argv[2]);
	sprintf(log_file,"%s.log",argv[0]);
	hz_log_init(0,"log",log_file );


	if ( argc < 5 )
	{
		lt_info("usage:%s ip enb_count(max 200) ue_count(1--16)/one_time  secs/one_time",argv[0]);
		return 0;
	}
	lt_info("ip =%s",argv[1]);



	#define SOCKET_COUNT  200//1000
	socket_creat_arg_t client[SOCKET_COUNT];
	//u32 count=strtol(argv[2],NULL,0);
	//lt_info("enb count=%d",count);
	u32 id=strtol(argv[2],NULL,0);
	u32 uecount=strtol(argv[3],NULL,0);
	u32 secs=strtol(argv[4],NULL,0);
	//if (i>=0 && i<200)
	
	//i=id;


	//for ( i=0;i<SOCKET_COUNT;i++)
	//for ( i=0;i<count;i++)
	{
		memset(&client[i],0,sizeof(client[i]));
		sprintf(client[i].ip_str,"%s",argv[1]);
		client[i].port=7777;
		//client[i].userdata[0]=i;
		client[i].userdata[0]=id;
		client[i].userdata[1]=uecount;
		client[i].userdata[2]=secs;
		client[i].thread_recv.thread_f=client_recv_handle;
		client[i].thread_send.thread_f=client_send_handle;
		thread_socket_tcp_c_creat(&client[i]);
		lt_msleep(10);
	}
	
	lt_info("hello done");
	while(1)
	{
		lt_sleep(1);
	}
	return 0;
}
